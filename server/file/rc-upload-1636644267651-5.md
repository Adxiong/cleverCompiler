[toc] 



# **一、Vue响应式原理**

首先回答对响应式的个理解，提出核心点是通过Object.defineProperty， Vue 在初始化数据时，会传入一个data对象，内部会默认的对data对象进行遍历，使用 Object.defineProperty 重新定义所有属性，当页面取到对应属性时。会进行依赖收集（收集当前组件的watcher） 如果属性发生变化会通 知相关依赖进行更新操作。 

data的属性被转化为getter和setter，并且记录相应的依赖，当它被改动时会通知相应的依赖
每个vue实例都有一个watcher实例，而watcher实例会依赖于相应的setter 
当数据变化时，setter会被调用，setter会通知对应的watcher，watcher会更新相应的视图

# **二、proxy数据代理是什么**

可以理解为在对象之前设置一个“拦截”，当该对象被访问的时候，都必须经过这层拦截。意味着可以在这层拦截中进行各种操作。比如你可以在这层拦截中对原对象进行处理，返回你想返回的数据结构。

ES6 原生提供 Proxy 构造函数，MDN上的解释为：Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）

# **三、计算属性和watch的区别**

**computed**

一个数据属性在它所依赖的属性发生变化时，也要发生变化，这种情况下，我们最好使用计算属性，computed是带缓存的，只有其引用的响应式属性（属性绑定）发生改变时才会重新计算(如果引用的属性没有改变，则调用上一次缓存值)

**watch**

watch适合处理的场景是，侦听一个数的变化，当该数据变化，来处理其他与之相关数据的变化（该数据影响别的多个数据）==当数据发生变化时，执行异步操作或较大开销操作的情况。

watch没有缓存直接执行

# **四、VueX的应用场景**

多个视图依赖于同一状态

来自不同视图的行为需要改变同一个状态

多个组件嵌套层级较多，用$emit传递过于繁琐

```JS
state：存放公共数据的地方
getter：获取公共数据的地方c
mutations：唯一修改state的方法，修改过程是同步的
action：异步处理，通过分发操作触发mutation 提交
module：将store模块分割，减少代码臃肿

```



# **五、v-for为啥要加Key**

**key的作用主要是为了高效的更新虚拟DOM！！！**

当v-for进行数据渲染列表时，如果数据量庞大，我们对列表进行增删改时就会重新渲染列表，这样会影响性能！

如果我们加上key那么列表修改是就会根据之前的key值判断是否更新数据，如果需要则更新数据，如果不需要就复用之前的数据

# **六、虚拟DOM和真实**DOM的区别

1、虚拟DOM不会进行排版与重绘操作

2、虚拟DOM就是把真实DOM转换为Javascript代码

3、虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要改的部分（注意！），最后并在真实DOM中进行排版与重绘，减少过多DOM节点排版与重绘损耗

真实DOM频繁排版与重绘的效率是相当低的

4、虚拟DOM有效降低大面积（真实DOM节点）的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部

- 4.1 步骤一：用JS对象模拟DOM树
- 4.2 步骤二：比较两棵虚拟DOM树的差异
- 4.3 步骤三：把差异应用到真正的DOM树上

# **七、基本数据类型和引用数据类型的区别**

**1.** 基本数据类型的存储

　　　　以 **栈 的形式存储, 保存与赋值指向数据本身,** **用type of 来判断类型,存储空间固定.**

**2.** 引用类型 Object

　　　　以 **堆 的形式存储, 它是存放在堆中的对象，其变量是存放在栈中的一个指针（即堆内存的引用地址），其指针指向堆内存, 用instance of 来判断类型 , 存储空间不固定**

# **八、深拷贝与浅拷贝**

**浅拷贝：**

Object.assign()

var obj1 = {a: 1, b: 2} var obj2 = Object.assign({}, obj1)

解构赋值

var obj1 = {a: 1, b: 2} var obj2 = {...obj1}

浅拷贝是引用了对象的值时其实是引用了其地址，并非堆对象的值，当改变值时，其对象的值也会发生改变

**深拷贝：**

利用json.parse(json.stringify());

利用递归

深拷贝则是在堆内存中开辟了新的地址，用来存放拷贝的对象

# 九、基本数据类型赋值和引用数据类型赋值的区别

**1、基本数据类型保存与赋值指向数据本身**

**2、引用类型是存放在堆中的对象，其变量是存放在栈中的指针（即堆内的引用地址），其指针指向堆内存**

# **十、为什么是js是单线程的**

JavaScript作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。

如果JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

# **十一、小程序的生命周期**

![](C:\Users\Administrator\Desktop\面试\2.jpg)

![](C:\Users\Administrator\Desktop\面试\3.jpg)

![](C:\Users\Administrator\Desktop\面试\4.jpg)

# **十二、jsonp的实现原理**

jsonp本质就是我们的函数的定义和函数的调用。

script本身属于一个一次性标签，所以需要动态去创建script

请求一次就需要创建一次script 通过src动态引入我们的函数调用

函数调用的参数，将数据传递过来，当然如果说我们前端在使用的时候，我们只需要去定义函数，通过函数中的参数就可以将数据获取过来

JSONP是一种非正式传输协议，该协议的一个要点就是允许用户传递一个callback参数给服务器端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了

# **十三、本地存储  localStorage sessionStorage cookie session**

localStorage/sessionStorage H5中新增加的API，基于这个API可以把一些数据缓存到客户端本地

| 特性         | cookie                                                 | session                            | localStorage            | sessionStorage |
| ------------ | ------------------------------------------------------ | ---------------------------------- | ----------------------- | -------------- |
| 数据声明周期 | 一般由服务器生成，可以设置过期时间                     | 一般由服务器生成，可以设置过期时间 | 除非被清理,否则一直存在 | 页面关闭就清理 |
| 数据储存大小 | 4K                                                     | 根据服务器大小决定                 | 5M                      | 5M             |
| 与服务端通信 | 每次都会携带在header中，服务器检查cookie，辨认用户状态 | 请求时携带在header中               | 不参与                  | 不参与         |

| 存放位置 | 当前浏览器的cookie中     | 存放在服务端        | 当前浏览器本地存储   | 当前浏览器本地存储                             |
| -------- | ------------------------ | ------------------- | -------------------- | ---------------------------------------------- |
| 是否安全 | 不安全                   | 安全                | 不安全               | 不安全                                         |
| 实际用途 | 记录登录时间，购物车收藏 | 存储账号密码设置key | 用来统计页面访问次数 | 记录当前进入用户的隐私数据，在关闭浏览器时删除 |

# **十四、token 和session 分别是什么有什么区别**

**什么是Session机制？**

Session是存储在服务器端的，当浏览器第一次请求Web服务器，服务器会产生一个Session存放在服务器里（可持久化到数据库中），然后通过响应头的方式将SessionID返回给浏览器写入到Cookie中，浏览器下次请求就会将SessiondID以Cookie形式传递给服务器端，服务器端获取SessionID后再去寻找对应的Session。如果找到了则代表用户不是第一次访问，也就记住了用户。

但需要注意的是，若服务器做了负载均衡，用户的下一次请求可能会被定向到其它服务器节点，若那台节点上没有用户的Session信息，就会导致会话验证失败。所以Session默认机制下是不适合分布式部署的。

**Token的出现是为了解决Session的弊端**

Token我们一般称为令牌，一般通过MD5、SHA算法将密钥、公钥、时间戳等元素加密产生的加密字符串。

浏览器访问Web服务器后认证成功后生成Token并返回给客户端，客户端浏览器后续的请求都会把这个Token带到服务器端去验证，以此判定请求是否合法。

**Session与Token的异同**

Session和Token机制原理上差不多，都是用户身份验证的一种识别手段，它们都有过期时间的限制，但两者又有一些不同的地方。

1、Session是存放在服务器端的，可以保存在：内存、数据库、NoSQL中。它采用空间换时间的策略来进行身份识别，若Session没有持久化落地存储，一旦服务器重启，Session数据会丢失。

2、Token是放在客户端存储的，采用了时间换空间策略，它也是无状态的，所以在分布式环境中应用广泛。

3.SSESION：银行排号

2、TOKEN  ：我发给你一张加密的身份证，以后你只要出示这张卡片，我就知道你一定是自己人。

# **十五、清除浮动8种方法**

1、父级div定义 height

2、结尾处加空div标签 设置CSS样式为 clear:both

3、父级div定义 伪类:after 和 zoom

.clearfloat:after{display:block;clear:both;content:"";visibility:hidden;height:0} .clearfloat{zoom:1}

4、父级div定义 overflow:hidden

5、父级div定义 overflow:auto

6、 父级div 也一起浮动

7、父级div 设置dispaly：table 

8，结尾处加br标签 设置CSS样式为  clear:both

# **十六、浏览器内核**

1、IE浏览器内核：Trident内核，也是俗称的IE内核；

2、Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核；

3、Firefox浏览器内核：Gecko内核，俗称Firefox内核；

4、Safari浏览器内核：Webkit内核；

5、Opera浏览器内核：最初是自己的Presto内核，后来是Webkit，现在是Blink内核；

6、360浏览器、猎豹浏览器内核：IE+Chrome双内核；

7、搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）；

8、百度浏览器、世界之窗内核：IE内核；

9、2345浏览器内核：以前是IE内核，现在也是IE+Chrome双内核；

# **十七、居中盒子的8种方法**

![img](C:\Users\Administrator\AppData\Local\YNote\data\weixinobU7VjmEaQQ55iDsoOd6jwhS8D64\d4c475bb15db42e1ad131bcb22ef9582\aelftksuqmcc.png)

![img](C:\Users\Administrator\AppData\Local\YNote\data\weixinobU7VjmEaQQ55iDsoOd6jwhS8D64\6a318166e7834afa95c586143a8c9e2f\615201064(1).png)

![img](C:\Users\Administrator\AppData\Local\YNote\data\weixinobU7VjmEaQQ55iDsoOd6jwhS8D64\b5454bee92e740f5a842a7f6ba0fc03e\suvork5cyii=.png)

![img](C:\Users\Administrator\AppData\Local\YNote\data\weixinobU7VjmEaQQ55iDsoOd6jwhS8D64\9f73c82813b847bfa320287938f63c17\aelftksuqmcc.png)

![img](C:\Users\Administrator\AppData\Local\YNote\data\weixinobU7VjmEaQQ55iDsoOd6jwhS8D64\1cf272cfc66e42a58a12f5ff56142838\615201108(1).png)

![img](C:\Users\Administrator\AppData\Local\YNote\data\weixinobU7VjmEaQQ55iDsoOd6jwhS8D64\8815a114419a45e38f7d1903457ea51f\615201118(1).png)

![img](C:\Users\Administrator\AppData\Local\YNote\data\weixinobU7VjmEaQQ55iDsoOd6jwhS8D64\66edc50b9d944dd2ac97ecc3df445814\615201131(1).png)

![img](C:\Users\Administrator\AppData\Local\YNote\data\weixinobU7VjmEaQQ55iDsoOd6jwhS8D64\a317550712454820be8bbfa66656e919\1615201155.png)

# **十八、BFC是什么？能解决什么问题？**

BFC是的子元素布局是不受外界的影响的

1、float的值不是none。

2、position的值不是static或者relative。

3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex

4、overflow的值不是visible

**1.避免外边距折叠**

**2.避免文字环绕**

**3.浮动元素不会乱跑。（包含浮动元素）**

# **十九、Ajax状态码**

0: (未初始化)还没有调用send()方法。

1: (载入)已经调用send()方法，正在派发请求。

2: (载入完成)send()已经执行完成，已经接收到全部的响应内容。

3: (交互)正在解析响应内容。

4: (完成)响应内容已经解析完成，用户可以调用。

# **二十、let，const，var**

**let**

let有块级作用域{}，外界无权修改 不能声明同名变量 let没有声明提前 定义值可以修改

**const**

const有块级作用域{}，为常量，一单赋值，无法修改 const声明对象无法修改键名，但可以修改值 const赋值不能为空 不能声明同名变量 const没有声明提前

**var**

var只在函数内部function有块级作用域 有声明提前 可以修改值 能够重复定于

# **二一、es5和es6中的作用域分别是什么？**

块级作用域

只要是有花括号的就是块级作用域

function if for {}

# **二二、函数作用域有哪些**

全局作用域

定义的变量或者方法所有的地方都可以使用到，释放的周期，是需要等到浏览器关闭以后才会释放。

局部作用域

只能是当前函数中能够使用到，而且只要调用完成以后就会释放 性能高

闭包

子函数能够使用父函数的局部变量，直到你去释放，释放方法就是return或者是 函数为null

# **二三、关于this**

函数中：window

方法中：当前方法属于谁就是谁

事件：当前发生事件的元素

定时器：window

new：空白构造对象本身

# **二四、window.onload DOMContentLoaded document.onreadstatechange 执行时机**

window.onload

页面中所有的资源加载完成，图片，音频，视频

DOMContentLoaded

在页面文档加载解析完毕之后马上执行。而不会等待图片文件和子框架页面的加载

onreadstatechange 监听页面状态

DOMContentLoaded>onloadstatechange>window.onload

# **二五、defer和async  script中**

defer和async是script标签的两个属性，用于在不阻塞页面文档解析的前提下（也就是非正常内联script脚本的情况下），控制脚本的下载和执行。

**script**

因为script是同步的所以再HTML加载时会下载和执行script文件 这样会阻塞HTML文档解析

**defer**

defer会在HTML元素加载时进行下载，但会在HTML元素加载完之后，DOMContentLoaded 事件触发之前进行执行script脚本，

**async**

async会在HTML元素加载时进行下载，单会在HTML元素未加载完成时就进行解析script文件

![img](C:\Users\Administrator\AppData\Local\YNote\data\weixinobU7VjmEaQQ55iDsoOd6jwhS8D64\da5cd5fd5fdc42b691def691d8265a8c\defer和async.jpg)

蓝色线代表网络读取（下载JS文件），红色线代表执行时间（执行JS文件），这俩都是针对脚本的；绿色线代表 HTML 解析。

**defer要注意**

1、只适合内联脚本（也就是script没有scr属性）

2、如果声明了多个defer脚本那么就会按顺序下载和执行

3、defer会在DOMContentLoaded和onLoad事件之前执行

**async要注意**

1、只适合内联脚本（也就是script没有scr属性）

2、如果声明了多个async也是异步下载与执行的没有先后顺序

3、anync在onLoad前执行，但不不能保证与DOMContentLoaded执行的先后顺序

# **二六、宏任务和微任务** event loop

- 执行一个宏任务（栈中没有就从事件队列中获取）
- 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
- 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
- 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
- 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

# **二七、堆和栈**

**1.** 基本数据类型的存储

　　　　以 **栈 的形式存储, 保存与赋值指向数据本身,** **用type of 来判断类型,存储空间固定.**

**2.** 引用类型 Object

　　　　以 **堆 的形式存储, 它是存放在堆中的对象，其变量是存放在栈中的一个指针（即堆内存的引用地址），其指针指向堆内存, 用instance of 来判断类型 , 存储空间不固定**

# **二八、状态码**

200 ok

304缓存的文档还可以继续使用。重定向

403 服务器已经理解请求，但是拒绝执行它

404 请求页面不存在

414请求的URI 长度超过了服务器能够解释的长度

500 服务器内部错误

502 服务器挂了

# **二九、Ajax实现过程**

 var aDiv=document.querySelector('div')   var xhr;   if(window.XMLHttpRequest){     xhr=new XMLHttpRequest()   }else{     xhr=new ActiveXObject()   }   xhr.onreadystatechange=function(){     if(xhr.readyState==4&&xhr.status==200){       aDiv.innerHTML=xhr.responseText     }   }   xhr.open('get','./app.json')   xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");   xhr.send()

# 三十、写出常用的数组变异方法(至少7个)

pop()
shift()
push()
unshift()
sort()
reverse()
splice()

# **三一、同步和异步的与原理**

同步：一个一个执行 例：过独木桥、排队买东西

异步：同时执行多个 例：电脑 一边听歌一边敲代码，网购

# **三二、get请求和post请求**

**get：**

1、通过地址栏传递、

2、传输量小 32k

3、不安全

4、分享和收藏 有缓存、

**post请求：**

1、传输量大

2、相对安全

3、body传递send

# **三三、跨域的解决办法**

1、 通过jsonp跨域

2、 跨域资源共享（CORS）

3、 nodejs中间件代理跨域

4、 ajax设置datatype：jsonp实现代理

5、使用vue-cli中在vue.config.js中配置proxy

# **三四.简述MVVM和MVC**     

MVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式： 

Model（模型）表示应用程序核心（如数据库）。

View（视图）显示效果（HTML页面）。

Controller（控制器）处理输入（业务逻辑）。

MVC 模式同时提供了对 HTML、CSS 和 JavaScript 的完全控制。

Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。

　　通常模型对象负责在数据库中存取数据。

View（视图）是应用程序中处理数据显示的部分。

　　通常视图是依据模型数据创建的。

Controller（控制器）是应用程序中处理用户交互的部分。

　　通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。

而MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。

\- Model(模型) 处理业务逻辑的操作

\- View(视图) 用于渲染数据的页面

\- VModel (view-model简称vm)负责视图和数据的双向数据绑定

# **三五.Vue中双向数据绑定是如何实现的**     

实现原理大致是，通过Object.defineProperty()方法来劫持Vue数据的属性，一旦监听到数据变化，则更新数据关联的虚拟DOM树，当然在模版编译的时候，为指令v-model绑定input事件，当输入的内容发生改变时，同步更新data中绑定的数据

# **三六.v-cloak有什么作用**     

防止页面加载时出现闪烁问题！

# **三七.请举例说明绑定事件传参的方法**

如果事件直接绑定函数名称，没有传参,那么默认会传递事件对象event作为事件函数的第一个参数

如果事件绑定函数调用，那么事件对象必须作为最后一个参数显示传递，并且事件对象的名称必须是$event

# **三八.单页面应用和多页面应用区别及优缺点**

单页面简称(SPA),原理:利用js感知到url的变化,可以通过js动态的将当前的页面内容清除掉,接着将下一个页面的内容挂载到当前的页面上,页面每次切换跳转时,并不需要做html请求,这样就节省了很多http发送延迟,切换速度更快.

优点:加载速度快,内容的改变不需要重新加载整个页面,对服务器压力小

前后端分离,视觉效果好

缺点:页面初次加载比较慢,页面复杂提高很多

多页面:一个应用多个页面,页面跳转时整个页面都刷新,每次都请求一个新的页面

优点:SEO效果好

缺点:页面切换慢,每次切换页面需要选择性的重新加载公共资源

# **三九、强缓存和协商缓存**

**强缓存**

respone header 的cache-control，常见的设置是max-age public private no-cache no-store等

一般设置：cahe-control:max-age=31536000,public,immutable

max-age表示缓存的时间是31536000秒（1年），public表示可以被浏览器和代理服务器缓存，当用户刷新页面时不管过没过期像服务器再次发送请求，这是相当于又走了协商缓存，设置immutable，就算用户刷新页面也不会进行请求

返回200

**协商缓存**

设置response header中的：

etag: '5c20abbd-e2e8' last-modified: Mon, 24 Dec 2018 09:49:49 GMT

etag是个hash值当用户每次请求时会携带，如果发生变化则缓存新的数据

返回304

**总结：像服务器发送请求缓存的过程就是协商缓存**

# **四十、长链接，短连接，长接口，短接口**

**短连接** 

连接->传输数据->关闭连接 

HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。 

也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。 

**长连接** 

连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。 

长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。

# **四十一、improt引入css和link引入css的区别**

**加载顺序**

link引入的css在加载页面时同时加载，而@import中的css要在页面加载完毕后加载

**从属关系**

link是HTML提供的标签

@import是css的语法规则，只能加载在style标签内和css文件中

**兼容性**

@import是css2.1时提出的，只能用于IE5+，而link不受兼容影响

**DOM可控性**

link支持js控制DOM改变样式，而@import不支持

# **四十二、防抖与节流**

在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。

### 防抖（debounce）

**所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。**



```JS
function debounce(fn, delay) {
  var timer = null;
  return function() {
    if (timer) clearTimeout(timer);
    timer = setTimeout(function() {
      fn();
    }, delay);
  }
}
```

### 节流（throttle）

**所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。**节流会稀释函数的执行频率。

对于节流，一般有两种方式可以实现，分别是时间戳版和定时器版。

# **四十三、回流和重绘**

回流必将引起重绘，而重绘不一定会引起回流。

### 重绘

比如：只有颜色改变的时候就只会发生重绘而不会引起回流

### 回流

 比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变

当页面布局和几何属性改变时就需要回流

# **四十四、原型链**

1、实例化对象的__proto__指向是目前构造函数的prototype

2、构造函数prototype的__proto__指向的是object的prototype

3、object.prototype的__proto__指向null

# **四十五、ES5的继承，call，apply**

**一、**	**原型链继承**

```JS
缺点：不能传参--不能将构造函数中的参数传到父构造函数中
优点：可以继承父函数原型对象的成员
语法：
	子函数.prototype=new 父函数
```

**二、****借用构造函数继承**

```JS
优点：可以传参
	缺点：不能继承父构造函数原型对象的成员
	语法：
		父构造函数.call（this）
 function Person(name,age){
        this.name=name
        this.age=age
    }
    Person.prototype.fn=function(){
        console.log('hhh')
    }
    function Woker(name,age,job){
        // 将Person的this指向转为Woker
        Person.call(this,name,age)
        this.job=job
    }
    let w1=new Woker('小王',18,'搬砖')
    let p1=new Person('小王',18,)
    console.log(w1)
    console.log(p1)
```



**三、****组合继承（混合继承）**

```JS
优点：子函数的实例化对象可以继承父函数原型对象的成员，可以传参
  function Person(name,age){
        this.name=name
        this.age=age
    }
    Person.prototype.fn=function(){
        console.log('hhh')
    }
    function Woker(name,age,job){
        //改变this指向 继承Person的属性
        Person.apply(this,arguments)
        this.job=job
    }
    Woker.prototype=Person.prototype
    // 使用原型链继承继承了方法
    let w1 =new Woker('小王',18,'搬砖')
    let p1 =new Person('小王',18)
    console.log(w1,p1)
```

**四、****拷贝式继承**

 ```JS
 function Person(name,age){
        this.name=name
        this.age=age
    }
    Person.prototype.fn=function(){
        console.log('hhh')
    }
    function Woker(name,age,job){
        Person.apply(this,arguments)
        this.job=job
    }
    let obj =Person.prototype
    // 遍历Person中的方法
    for(var key in obj){
        //通过for in 添加到Woker的原型中
        Woker.prototype[key]=obj[key]
    }
    let w1=new Woker('小王',18,'搬砖')
    let p1=new Person('小王',18)
    console.log(w1)
    console.log(p1)
 ```

**五、寄生式继承**

```JS
function Person(name, age) {
        this.name = name
        this.age = age
    }
    Person.prototype.fn = function () {
        console.log('hhh')
    }
    function Woker(name, age, job) {
        //改变this指向 继承Person的属性
        Person.apply(this, arguments)
        this.job = job
    }
    Woker.prototype=new Person()
    Woker.prototype.constructor=Woker
    //将woker的构造函数指向回woker
    let w1=new Woker('小王',18,'搬砖')
    let p1=new Person('小王',18)
    console.log(w1)
    console.log(p1)
```

# **四十六、ES6新增特性**

const 与 let 变量

模板字符串

解构赋值

promise

对象属性和方法的简写

数组新增方法

浅拷贝的assgin方法

# **四十七、js分为哪三部分**

1、ECMAScript(JavaScript语法 )

2、DOM 页面文档对象模型

3、BOM 浏览器对象模型

# **四十八、jq的链式调用**

jq的方法都是挂在原型的，那么如果我们每次在内部方法返回this，也就是返回实例对象，那么我们就可以继续调用原型上的方法了，这样的就节省代码量，提高代码的效率，代码看起来更优雅。

# **四十九、什么是事件流，事件流的分类**

页面触发一个事件时，会按照一定的顺序来响应事件，事件的响应过程为事件流

就我个人理解就是网页对点击事件的排序顺序就是事件流

1、冒泡型的事件流（任何一款浏览器都支持）

从明确事件源到不明确的事件源依次向上响应。

2、捕获型的事件流（从IE8及以下版本支持）

从不确定事件源到确定事件源依次向下响应。

# **五十、浏览器前缀**

-ms-  ie浏览器

-moz- 火狐浏览器

-o- opera浏览器

-webkit-  Chrome safari

# **五十一、keep-alive**

//当我们访问别的组件时，其他的组件会被销毁 //我们需要用keep-alive 保证 组件不被销毁会被缓存 语法：<keep-alive><router-view></router-view></keep-alive> //如果想让其中一个组件不被销毁需要在keep-alive中额外添加属性 include=‘name名’ 	//只有匹配的组件会被缓存 exclude='name名' 	//匹配的组件不会被缓存 <keep-alive exclude="about">

# **五十二、输入一串url发生了什么事**

1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

# **五十三、js23种模式**

总体来说设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

# **五十四、做过那些前端优化**

1、节流、防抖

2、重绘、回流

3、对代码进行压缩，删除不必要的空格

4、图片的懒加载

5、js是阻塞的 合理的使用defer和async

# **五十五、前端常见攻击方法**

**A: XSS** 

恶意攻击者往Web页面里插入Script代码

**B: CSRF**

(1) 用户在a站前端发起请求

(2) a站后端确认身份，登录成功，cookie中存在用户的身份认证信息

(3) 用户未退出网站a之前，在同一浏览器中打开一个TAB页访问第3方站点b

(4) b站前端带着a站的cookie信息向a站后端发起请求，请求成功

**C: SQL注入**

在编写代码时，没有对用户输入的数据进行合法性判断，使得程序出现安全隐患。黑客可以把SQL命令插入Web表单提交或输入域名或页面请求的查询字符串，根据返回的结果，来获得他想要的数据。这就是SQL Injection，即SQL注入。

# **五十六、双飞翼布局**

双飞翼布局是把朱列嵌套在一个父级块中利用主列的左、右外边距进行布局调整的

# **五十七、圣杯布局**

圣杯布局是利用父容器的左、右内边距+两个从列相对定位

# **五十八、怎么设置事件捕获**

addEventListener 的第三个参数设置为true 则将事件冒泡转为事件捕获

# **五十九、http和https的区别**

1、HTTPS 协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)

2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。

3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

# **六十、前端工程化有哪些**

## 模块化

模块化只是在文件层面上，对代码或资源的拆分；

## 组件化

而组件化是在设计层面上，对UI（用户界面）的拆分。

## 规范化

- 目录结构的制定
- 编码规范
- 前后端接口规范
- 文档规范
- 组件管理
- Git分支管理
- Commit描述规范
- 定期CodeReview
- 视觉图标规范

## 自动化

自动化测试

持续集成

自动化构建

自动化部署

# **六十一、git常用指令**

```JS
git branch 查看本地所有分支
git status 查看当前状态 
git commit 提交 
git branch -a 查看所有的分支
git branch -r 查看本地所有分支
git commit -am "init" 提交并且加注释 
git remote add origin git@192.168.1.119:ndshow
git push origin master 将文件给推到服务器上 
git remote show origin 显示远程库origin里的资源 
git push origin master:develop
git push origin master:hb-dev 将本地库与服务器上的库进行关联 
git checkout --track origin/dev 切换到远程dev分支
git branch -D master develop 删除本地库develop
git checkout -b dev 建立一个新的本地分支dev
git merge origin/dev 将分支dev与当前分支进行合并
git checkout dev 切换到本地dev分支
git remote show 查看远程库
git add .
git rm 文件名(包括路径) 从git中删除指定文件
git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来
git config --list 看所有用户
git ls-files 看已经被提交的
git rm [file name] 删除一个文件
git commit -a 提交当前repos的所有的改变
git add [file name] 添加一个文件到git index
git commit -v 当你用－v参数的时候可以看commit的差异
git commit -m "This is the message describing the commit" 添加commit信息
git commit -a -a是代表add，把所有的change加到git index里然后再commit
git commit -a -v 一般提交命令
git log 看你commit的日志
git diff 查看尚未暂存的更新
git rm a.a 移除文件(从暂存区和工作区中删除)
git rm --cached a.a 移除文件(只从暂存区中删除)
git commit -m "remove" 移除文件(从Git中删除)
git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)
git diff --cached 或 $ git diff --staged 查看尚未提交的更新
git stash push 将文件给push到一个临时空间中
git stash pop 将文件从临时空间pop下来
---------------------------------------------------------
git remote add origin git@github.com:username/Hello-World.git
git push origin master 将本地项目给提交到服务器中
-----------------------------------------------------------
git pull 本地与服务器端同步
-----------------------------------------------------------------
git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。
git push origin serverfix:awesomebranch
------------------------------------------------------------------
git fetch 相当于是从远程获取最新版本到本地，不会自动merge
git commit -a -m "log_message" (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：
git branch branch_0.1 master 从主分支master创建branch_0.1分支
git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0
git checkout branch_1.0/master 切换到branch_1.0/master分支
du -hs

-----------------------------------------------------------
mkdir WebApp
cd WebApp
git init
touch README
git add README
git commit -m 'first commit'
git remote add origin git@github.com:daixu/WebApp.git
git push -u origin master
```

# **六十二、promise解决了什么问题**

- 同步的方式写异步的代码，用来解决回调地狱问题。
- 此外，promise对象提供统一的接口，使得控制异步操作更加容易

# **六十三、vue中的diff算法**

用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文 档当中

当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较(diff)，记录两棵树差异

把第二棵树所记录的差异应用到第一棵树所构建的真正的DOM树上(patch)，视图就更新了

diff整体策略为：深度优先，同层比较

1、比较只会在同层级进行, 不会跨层级比较

2、比较的过程中，循环从两边向中间收拢

新节点有孩子

清空老节点文本

创建孩子并追加

老节点有孩子，删除即可

老节点存在文本，清空

双方都是文本节点，跟新文本

# **六十四、commit常用类型**

feat:: 类型为 feat 的提交表示在代码库中新增了一个功能（这和语义化版本中的 MINOR 相对应）。

fix:：类型为 fix 的 提交表示在代码库中修复了一个 bug （这和语义化版本中的 PATCH 相对应）。

docs:: 只是更改文档。

style:: 不影响代码含义的变化（空白、格式化、缺少分号等）。

refactor:: 代码重构，既不修复错误也不添加功能。

perf:: 改进性能的代码更改。

test:: 添加确实测试或更正现有的测试。

build:: 影响构建系统或外部依赖关系的更改（示例范围：gulp、broccoli、NPM）。

ci:: 更改持续集成文件和脚本（示例范围：Travis、Circle、BrowserStack、SauceLabs）。

chore:: 其他不修改src或test文件。

revert:: commit 回退。

# **六十五、什么是高阶函数**

一、函数的参数是一个函数

二、函数返回一个函数

# **六十六、原生APP和混合APP的判断方法**

# **六十七、NPM更改源 查询源**

npm config set registry [https://registry](https://registry/).npm.taobao.org

npm config get registry

npm install -g cnpm --registry=[https://registry](https://registry/).npm.taobao.org

# **六十八.自定义过滤器的语法是什么?**

filter('过滤器名',function(val){return 返回的值})

# **六十九、为什么使用继承**

1、减少无用的多次重复代码

2、使用户体验更高、加载更快

# **七十、IIFE是什么？**

中文名：自执行函数

(function(形参){ alert('哈哈') })(实参)

**作用？**

1、隐藏实现

2、不会污染外部（全局）命名空间

3、用它来编写js模块

# **七十一、js引擎如何管理内存**

内存生命周期

1、开辟小块内存，获得试用权限

2、存储数据，进行操作（可以反复操作）

3、释放小内存空间

释放内存***

局部变量：函数执行完自动释放

对象：生成对象后，变量不会消失，需要垃圾回收机制清除！

# **七十二、全局执行上下文是什么？**

1. 发生在在执行全局代码前，将window作为全局执行上下文
2. 对全局变量进行预处理

2.1.将var定义的变量赋值给window，并且值为underfined

2.2.将function声明全局函数赋值给window(值为fun)

2.3.将this指向window

1. 开始执行全局代码

# **七十三、函数执行上下文是什么？**

在函数调用之前，创建对应的函数的执行上下文的环境 对局部执行上下文环境进行预处理  函数调用时入栈 调用结束出栈

# **七十四、执行上下文栈**

1.在全局代码之前，js引擎会创建一个栈来存储管理当前所有执行上下文的对象

2.当全局执行上下文(window)确定后，会将其添加到栈中（压栈）

3.当函数执行上下文创建后，将其添加到栈中（压栈）

4.在当前的函数执行完之后，会将其创建的上下文对象移除栈

5.当所有的代码执行完之后，栈中将只剩下window

# **七十五、vue前端路由实现的原理是什么？**

前端路由是基于hash值的变化进行实现的

核心是依靠一个事件，即监听hash值变化的事件

# **七十六、请简述嵌套路由概念**

当我们进行路由的时候显示的组件中的内容还有子级路由的链接以及内容。

# **七十七、什么是动态路由?**

可以在一个路由中设置多段“路径参数”，对应的值都会设置到$route.params中

# **七十八、简述4种获取的动态路由参数的方式?**

通过$route.params来获取路径参数

通过props['参数变量名']来接收参数

将props设置为对象，那么就直接将对象的数据传递给组件进行使用，组件用props['参数变量名']

如果想要获取传递的参数值还想要获取传递的对象数据，那么props应该设置为函数形式

# **七十九、写出命名路由基本语法**

```JS
<router-link :to="{name:'xxx',params:{id:32}}">链接文字</router-link>
	script:
		news={
			template:""
		}
		var router=new VueRouter({
			routes:[
				{name:"xxx",path:"/news/:id",component:news}
			]
		})
```

# **八十、请详细说明vue的导航方式有几种**

```JS
1. 声明式导航：通过点击链接的方式实现的导航
<router-link to="/user">User1</router-link>
2. 编程式导航：调用js的api方法实现导航，如js代码： 
this.$router.push( { name:'user' } )
```

# **八十一、请写出7种编程式导航的实现**

```JS
    this.$router.push("hash地址");
	this.$router.push("/login");
	this.$router.push({ name:'user' , params: {id:123} });
	this.$router.push({ path:"/login" });
	this.$router.push({ path:"/login",query:{username:"jack"} });
	this.$router.go( n ); //n为数字，参考history.go
	this.$router.go( -1 );
```



# **八十二、简述promise静态方法all()和race()的区别**

数组中只有有一个promise实例被reject那么最终promise触发catch，只有数组中全部promise实例的resolve才触发then，并且要带上iterable中全部promise

# **八十三、渐进式框架的理解**

渐进式框架，主张问题较少，也就是弱主张，没有那多的硬性要求，例如angular必须使用它的模块机制，依赖注入。。。，react的函数式编程理念，vue就是没有啥主张，可以在原有系统上面，引入vue核心库直接就可以根据自己需要再去逐渐增加功能。（如，组件系统、路由、状态机等）

# **八十四、请写出你知道的事件修饰符（至少5种）**

.stop .prevent .self  vue.config.keyCodes .keyup .keydown

# **八十五、自定义指令有什么用?自定全局指令的语法及如何作用**

```JS
\- 内置指令不能满足我们特殊的需求 - Vue允许我们自定义指令 Vue.directive('指令名',{        inserted:function(el){                    }    }) Vue.directive('指令名',{        bind:function(el,binding){                    }    })
```

# **八十六、简述注册局部自定义指令方法**

```JS
directives:{ 指令名:{     inserted:function(el){ 	}     } } directives:{ 指令名:{     bind:function(el,binding){ 	}     } }
```

# **八十七、过滤器有什么用?**

**- Vue.js允许自定义过滤器，可被用于一些常见的文本格式化。**

**- 过滤器可以用在两个地方：双花括号插值和v-bind表达式。**

**- 过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示**

# **八十八、vue生命周期概念及作用**

Vue的生命周期：Vue实例从创建到销毁的过程 ,

   生命周期作用：生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑

# **八十九、VueX刷新页面数据丢失怎么解决**

1、localStorage: localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。

2、sessionStorage:sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。

3、cookie:cookie生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右,有个数限制（各浏览器不同），一般不能超过20个。缺点是不能储存大数据且不易读取。

# **九十、导航守卫**中的处于当前活跃状态

- to: Route: 来到了哪
- from: Route: 从哪来

# **九十一、静态路由和动态路由的区别**

静态路由是启动应用的时候把所有路由模块都加载进来

动态路由是当你访问到这个页面，才把对应的组件加载

# **九十二、OSI七层模型**

**开放式系统互联通信参考模型**（英语：Open System Interconnection Reference Model，缩写为 OSI），简称为**OSI模型**（OSI model），一种[概念模型](https://baike.baidu.com/item/概念模型/3187025)，由[国际标准化组织](https://baike.baidu.com/item/国际标准化组织/779832)提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。定义于ISO/IEC 7498-1。

#### **1、物理层**

在OSI参考模型中，物理层（Physical Layer）是参考模型的最低层。物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。

#### **2、数据链路层**

数据链路层（Data Link Layer）是OSI模型的第二层，负责建立和管理节点间的链路。该层的主要功能是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。

#### **3、网络层**

网络层（Network Layer）是OSI模型的第三层，它是OSI参考模型中最复杂的一层。它在下两层的基础上向资源子网提供服务。其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺 序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。一般地，数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。例如在广域网之间通信时，必然会遇到路由（即两节点间可能有多条路径）选择问题。

#### **4、传输层**

传输层（Transport Layer）是OSI模型的第4层。因此该层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。该层的主要任务是：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。该层常见的协议：TCP/IP中的TCP协议和UDP协议。传输层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时，对数据进行分割。然后，传输层将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此，传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作。综上，传输层的主要功能如下：监控服务质量。

#### 5、会话层

会话层（Session Layer）是OSI模型的第5层，是用户应用程序和网络之间的接口，主要任务是：向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层 的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。 用户可以按照半双工、单工和全双工的方式建立会话。当建立会话时，用户必须提供他们想要连接的远程地址。而这些地址与MAC（介质访问控制子层）地址或网络层的逻辑地址不同，它们是为用户专门设计的，更便于用户记忆。

#### 6、表示层

表示层（Presentation Layer）是OSI模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等。

#### 7、应用层

应用层（Application Layer）是OSI参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。它在其他6层工作的基础上，负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及 应用所需的监督、管理和服务等各种协议。此外，该层还负责协调各个应用程序间的工作。

# **九十三、tcp/ip5层模型**

**一、物理层**

物理层（Physical Layer）也称为一层，这一层的处理单位是比特（bit），它的主要功能是完成相邻节点之间比特（bit）的传输。

**二、数据链路层**

数据链路层（Data Link Layer）也称二层，这一层的处理单位是帧（Frame）。数据链路层的主要功能是：负责对物理层数据添加物理地址信息和必要的控制信息等，形成帧，并在传输路上进行无差错的传送。

数据链路层寻址采用的是物理地址，在常见的以太网中指的是MAC地址。MAC地址是固化在网卡上面的，全球唯一的，用48位二进制数标识。

**【重要概念】**

硬件物理地址（MAC）地址：MAC地址是固化（烧录）在网卡里的，也叫硬件地址，是由48位(6字节，一个字节=8位)二进制的数字组成。

如：44-4A-53-54-00-00（16进制表示）。48位二进制数转换为十六进制时是每4位转换成一个16十六进制字符的。所以48/4=12个十六进制字符，同时8位二进制数代表一个字节，这样我们看到的MAC地址正好是六段。

也就是说，在网络底层的物理传输过程中，是通过物理地址来识别主机的，它一般也是全球唯一的。

**三、网络层**

网络层（Network Layer）也称三层，这一层的处理单位是包（Packet），这里的地址称逻辑地址，即IP地址。三层可以建立网络连接和为上层提供服务。

**四、传输层**

传输层（Transport Layer）也称四层，这一层的处理单位是报文段（Segment，TCP时使用）/用户数据报（User Datagram，UDP时使用）。传输层在源节点和目的节点的两个进程实体之间提供端到端的数据传输。

**五、应用层**

应用层包括所有的高层协议。应用层不仅直接和应用程序接口而且提供常见的网络应用服务。

应用的概念和协议发展得很快，使用面又很广泛，这给应用功能的标准化带来了复杂性和困难性。比起其它层来说，应用层需要的标准最多，但也是最不成熟的一层。但随着应用层的发展，各种特定应用服务的增多，应用服务的标准化开展了许多研究工作。

# **九十四、html头部都有哪些组成meta**

# **九十五、父组件与子组件的生命周期怎么执行顺序**

```JS
**加载渲染过程**

父beforeCreate-->父created-->父beforeMount-->子beforeCreate-->子created--> 子beforeMount-->子mounted-->父mounted

**子组件更新过程**

父beforeUpdate-->子beforeUpdate-->子update-->父updated

**父组件更新过程**

父beforeUpdate-->父updated

**销毁过程**

父beforeDestroy-->子beforeDestroy-->子destroyed-->父destroyed
```

# 九十六、flash和js通过什么类如何交互?

```JS
Flash提供了ExternalInterface接口与JavaScript通信，ExternalInterface有两个方法，call和addCallback：

ExternalInterface.addCallback("在js里可调用的flash方法名",flash内方法) //在flash中通过这个方法公开 在js中可调用的flash内的方法;
ExternalInterface.call("js方法",传给js的参数) //在flash里调用js里的方法
```

# 九十七、HTML的Doctype和严格模式与混杂模式的描述

# 九十八、CSS Sprites

# 九十九、bom对象中的history

```JS
length 返回浏览器历史列表中的URL数量。 

back() 加载 history列表中的前一个URL。 

forward() 加载  history  列表中的下一个URL。 

go()  加载history列表中的某个具体页面。
```

# 一零零、阻止默认事件和冒泡

```JS
阻止默认事件： 
e.preventDefault() 
e.returnValue = false  (IE) 
阻止冒泡： 
e.stopPropagation() 
e.cancelBubble = true (IE)
```

# 一零一、正则表达式

# 一零二、逗号表达式

```JS
在for循环中如果写入两个条件表达式 i<10,j<6 那么只有后者的判断有效
```

# 一零三、重构理解

```JS
不影响之前功能的情况下 对网站进行优化 并进行拓展

js  css可读性增强 
```

# 一零四、MVVM,MVC

```JS
MVVM的概念最早是没有的，是从后端借鉴过来的MVC
M数据
V 页面
C业务逻辑
最早的出发点在V页面中然后从C中去拿数据，然后M把数据返回给V
因为所有的逻辑都写在C中所以：
C比较庞大不便于维护和操作
耦合度太高  修改V 会牵动M和C
```

```JS
MVVM 解决MVC问题
M数据
V页面
VM组件  业务逻辑提取到组件
耦合度不高
```

# 微信小程序知识点

# 一零五、subPackages 分包加载

因为小程序主包大小不超过2M 限制，所以使用分包是个不错的选择，总分包大小不超过8M，可以添加多个分包，分包加载可以优化小程序首次启动的下载时间，当进入分包页面再进行下载，这种按需加载可以把某些数据量大的抽离出来放入分包（如图表）

# 一零六、rpx 单位

在做移动端最常用适配的方法就是使用 rem 或 vw 作为单位来进行适配，所以微信小程序提供了 rpx 单位来进行适配

# 一零七、授权弹窗

wx.getUserInfo 接口调整，以前可以直接主动调用显示授权弹窗 ，现在需要使用 <button open-type="getUserInfo"></button> 点击来引导用户去授权，小程序 wx.getUserInfo 接口正式版已调整，体验版和开发版还可以使用原有方式

# 一零八、原生组件 z-index

原生组件的层级是最高的，所以页面中的其他组件无论设置 z-index 为多少，都无法盖在原生组件上，可以通过 cover-view 来解决，但某些特定环境如 swiper 或弹窗中需要显隐原生组件，需要配合 hidden 来使用

# 一零九、伪元素

小程序的伪元素属性无法在微信开发者工具 css 属性中看到，所以对于某些组件样式无法覆盖时（如 button 的边框或某些线条设置），是因为通过伪元素 ::after 设置的，所以必须使用伪元素来覆盖

# 一一零、页面栈

一个应用同时只能打开5个页面栈，当已经打开了5个页面之后（现在限制是10层），后续可能出现不能正常打开新页面。wx.navigateTo 跳转会保留当前页面，wx.redirectTo 则不会，所以请避免多层级的交互方式来合理使用跳转方式

# 一一一、组件化

template 模块与 component 组件，是小程序中组件化的方式，二者的区别是，template 模块主要是展示，方法需要在使用 template 的页面中定义。而 component 组件，则拥有自己的js 文件，整个 component 组件类似一个 page 页面。简单来说，只是展示用，建议使用 template，组件中涉及到较多的逻辑，建议使用 component

# 一一二、调式

一、开发者工具 source 断点调式、console.log 打印数据和 AppData 查看数据

二、小程序注意当前调式基础库版来调式一些兼容性以及 bug 问题

三、小程序先在开发版或体验版右上角打开调试显示 vConsole，再切到正式版就能看到 vConsole 模式

# 一一三、数据传递

一、使用数据缓存，wx.setStorage 和 wx.getStorage，存储数据只能是字符串格式，所以一般设置时需要使用 JSON.stringfy 来把对象转字符串，获取时使用 JSON.parse 来还原成对象

二、wx.navigateTo 跳转传递参数，在跳转 url 后拼接字符串，在 onLoad() 函数内，通过 options.参数名 的方式获取传递的参数，注意如果有特殊字符（如?#等）,可以使用encodeURIComponent 和 decodeURIComponent 编码和解码，否则会被截断，导致特殊字符后面的数据无法传递

三、getCurrentPages() 函数用于获取当前页面栈的实例，可以获取页面栈或修改页面栈数据

四、getApp() 可以获取全局对象和方法

# 一一四、导航栏胶囊对齐适配

导航栏一般使用自定义，比较灵活可控，首先需要 app.json 中设置 navigationStyle ：custom 自定义，然后通过小程序 wx.getMenuButtonBoundingClientRect() 可以获取到右上角胶囊菜单位置信息，不过这个接口不稳定，部分机型会出现获取失败的 bug，所以使用 wx.getSystemInfo 来获取该设备的状态栏高度（即手机时间和电量那一栏高度），标题栏高度（即包括导航返回键、标题和胶囊的高度）默认设置安卓为48，ios 为44（小程序默认胶囊在安卓中为48px 的标题栏居中，因为安卓类别比较多，所以会有点差别，ios 为44px 的标题栏居中），导航栏总高度为状态栏高度+标题栏高度，padding-top 高度为状态栏高度，标题栏中元素垂直对齐来达到适配并与胶囊对齐，设置内容高度时可以利用 calc(100vh - 导航栏总高度)，把样式放在全局 app.wxss 中

# 一一五、unionid 标识

unionid 是小程序用户的跨程序标识，拥有 unionid 首先需要绑定微信开放平台（[微信开放平台](https://open.weixin.qq.com/)-管理平台-小程序-绑定小程序），因为 unionid 就是微信开放平台分发下来的，不将小程序绑定微信开放平台，就没有 unionid，当不同小程序的 unionid 是不同的，需要把小程序挂载到同一个主体中，同一用户，对同一个微信开放平台下的不同应用，unionid 是相同的

后台返回 unionid 给前端：首先 wx.login 获取用户登录凭证code，然后 wx.getSetting 查看是否已授权，wx.getUserInfo 获取用户信息，通过用户信息的加密字段给后台向微信服务器换取 unionid 返回，由于获取请求返回数据可能会在 Page.onLoad 之后才返回， 所以一般加上 callback （获取 unionid 一般放在 app.js 的 onLaunch 中，所以需要 callback 来处理 它和页面 onLoad 的数据获取）

# 一一六、接口请求

建议把所有请求抽离到同一个 api.js 中，可以方便后期的修改和排查问题，小程序请求是通过微信后台来请求我们的后台地址来进行后端映射、你请求的接口实际到微信的后端做了一道映射，微信后端拿到你的 wx.request 调用的 url、用后端请求后端，所以不会出现跨域问题

# 一一七、input 键盘

考虑不同场景使用不同的 type，如文本键盘，数字键盘来提高用户体验

# 一一八、wux-weapp

小程序组件比较推荐 wux-weapp，组件丰富并且拓展灵活

# 一一九、Vue**为什么组件的data必须是一个函数**

一个组件可能在很多地方使用，也就是会创建很多个实例，如果data是一个对象的话，对象是引用类型，一个实例修改了data会影响到其他实例，所以data必须使用函数，为每一个实例创建一个属于自己的data，使其同一个组件的不同实例互不影响。

# 一二零、**template预编译是什么？**

对于 Vue 组件来说，模板编译只会在组件实例化的时候编译一次，生成渲染函数之后在也不会进行编译。因此，编译对组件的 runtime 是一种性能损耗。

而模板编译的目的仅仅是将template转化为render function，这个过程，正好可以在项目构建的过程中完成，这样可以让实际组件在 runtime 时直接跳过模板渲染，进而提升性能，这个在项目构建的编译template的过程，就是预编译。

# 一二一、如何让`CSS`只在当前组件中起作用

将当前组件的`<style>`修改为`<style scoped>`。

# 一二三、`active-class`是哪个组件的属性？

`vue-router`模块的`router-link`组件。

# 一二四、`vue-router`有哪几种导航钩子？

共分三种。

第一种：**全局导航钩子**：`router.beforeEach(to,from,next)`，作用：跳转前进行判断拦截。 全局前置守卫

第二种：**组件内钩子**；

```JS
const Foo = {
  template: `...`,
  beforeRouteEnter(to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate(to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave(to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
  }
}
```



第三种：**单独路由独享组件**；

```JS
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
        // ...
      }
    }
  ]
})
```



# 一二五、Vue插槽：slot、slot-scope与指令v-slot使用方法区别讲解

https://shq5785.blog.csdn.net/article/details/106742853

## 不具名插槽

```JS
<body>
   <div id="app">
      <Test>
         <div>slot插槽占位内容</div>
      </Test>
   </div>
   <template id="test">
      <div>
         <slot></slot>//定义插槽
         <h3>这里是test组件</h3>
      </div>
   </template>
   
</body>

<script>
   Vue.component('Test',{
      template:"#test"
   });

   new Vue({
      el:"#app",
   })
</script>

```

## 具名插槽

```JS
<body>
   <div id="app">
      <Test>
         <div slot="header">这里是头部</div>//具名插槽使用
         <div slot="footer">这里是尾部</div>
      </Test>
   </div>
   <template id="test">
      <div>
         <slot name="header"></slot>//具名插槽
         <h3>这里是Test组件</h3>
         <slot name="footer"></slot>
      </div>

   </template>
</body>
<script>
   Vue.component(
      'Test',{
         template:"#test"
   });
   new Vue({
      el:"#app"
   })

</script>

```

## v-slot

`v-slot`在组件中使用slot进行占位时，也是在slot标签内使用name 属性给slot插槽定义一个名字。但是在html内使用时就有些不同了。需要使用template模板标签，template标签内，使用v-slot指令绑定插槽名，标签内写入需要添加的内容.

```JS
<body>
   <div id="app">
      <Test>
         <template v-slot:header>//v-slot指令使用插槽
            <h2>slot头部内容</h2>
         </template>
         
         <p>直接插入组件的内容</p>
         
         <template v-slot:footer>
            <h2>slot尾部内容</h2>
         </template>
      </Test>
   </div>
   
   <template id ='test'>
      <div class="container">
         <header>
            <!-- 我们希望把页头放这里 -->
            <slot name = "header"></slot>//具名插槽
         </header>
         <section>
            主体内容部分
         </section>
         <footer>
            <!-- 我们希望把页脚放这里 -->
            <slot name = 'footer'></slot>
         </footer>
      </div>
   </template>
   
</body>

<script>
   Vue.component('Test',{
      template:"#test"
   });
   new Vue({
      el:"#app"
   })
</script>

```

## 作用域插槽：

slot-scope使用：

1. 在组件模板中书写所需slot插槽，并将当前组件的数据通过v-bind绑定在slot标签上。

2. 在组件使用时，通过slot-scope=“scope”,接收组件中slot标签上绑定的数据。

3. 通过scope.xxx就可以使用绑定数据了

   ```html
   <body>
      <div id="app">
         <Test>
            <div slot="default" slot-scope="scope">//作用域插槽的用法（slot-scope）
               {{ scope.msg }}
            </div>
            
         </Test>
      </div>
   
      <template id="test">
         <div>
            <slot name="default" :msg="msg"> </slot>
            <p>这里是test组件</p>
         </div>
      </template>
   </body>
   
   ```

   ```JS
   <script>
      new Vue({
         el:"#app",
         components:{
            'Test':{
               template:"#test",
               data(){
                  return {
                     msg:"你好"
                  }
               },
            }
         }
      })
   </script>
   ```

   

# 一二六、异步组件方法

## 方法一：webpack的另一种代码分割(推荐)  异步组件加载方法

此方法，多个路由指定相同的hcunkName，会打包成一个js文件。vue官网推荐使用webpack的代码分割进行懒加载。此方法依赖于Promise。

![img](https:////upload-images.jianshu.io/upload_images/8054470-277d62d017ecb49f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

webpack代码分割

webpack编译时，会静态的解析代码中的require.ensure()，同时将模块添加到一个分开的chunk中，新的chunk会被webpack通过jsonp来按需加载。此方法内部依赖于Promise。

参数1：是字符串数组，模块的依赖，会提前加载。一般都是空的。

参数2：依赖项加载完成之后的回调函数

  所有的依赖加载完成之后，webpack会执行这个回调函数，require对象的一个实现会作为一个参数传递给回调函数，因此，可以require依赖和其他模块提供下一步的执行。

参数3：chunk名称

  相同chunk名称的文件 所有依赖都会被放进相同文件束。

  我解释一下这个原理啊，在网上找了挺久，都是使用方法，不知道它到底做了什么，才实现的异步加载。

  webpack把这个模块导出一个js文件，然后用到这个模块的时候，就动态构造script标签插入DOM，再由浏览器去请求。回调函数是在依赖加载完成之后执行。

## 方法二：

```
import loading from "./loading";
import ErroCom from "./ErroCom";
const AsyncList = ()=>({
  component:import("./yibuzujian"),
  loading: loading, //loading组件
  error:ErroCom,//错误展示
  delay:200,//延迟
  timeout:500,//如果3秒没有加载，就出现error组件
})
export default {
  components:{
    AsyncList
  },
```

# 一二七、Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？

```JS
 原因在于在Vue实例创建时， obj.b 并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局api—— $set()：

  addObjB () {
        // this.obj.b = 'obj.b'
        this.$set(this.obj, 'b', 'obj.b')
        console.log(this.obj)
      }
```

# 一二八、 jQuery获取的dom对象和原生的dom对象有何区别？

 js原生获取的dom是一个对象，jQuery对象就是一个数组对象，其实就是选择出来的元素的数组集合，所以说他们两者是不同的对象类型不等价。

# 一二九、怎样理解Vue的单向数据流

所有的 prop 都使得其父子 prop 之间形成了一个**单向下行绑定**：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。

额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你**不**应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。

# 一三零、proxy和defineproperty区别优劣分析

**Proxy 的优势如下:**

- Proxy 可以直接监听对象而非属性；
- Proxy 可以直接监听数组的变化；
- Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；
- Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；
- Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；

**Object.defineProperty 的优势如下:**

- 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。

# 一三一、Vue3.0特性

## **1，压缩包体积更小**

当前最小化并被压缩的 Vue 运行时大小约为 20kB（2.6.10 版为 22.8kB）。Vue 3.0捆绑包的大小大约会减少一半，即只有10kB！

## **2，Object.defineProperty -> Proxy**

Object.defineProperty是一个相对比较昂贵的操作，因为它直接操作对象的属性，颗粒度比较小。将它替换为es6的Proxy，在目标对象之上架了一层拦截，代理的是对象而不是对象的属性。这样可以将原本对对象属性的操作变为对整个对象的操作，颗粒度变大。

javascript引擎在解析的时候希望对象的结构越稳定越好，如果对象一直在变，可优化性降低，proxy不需要对原始对象做太多操作。

### 3，Setup函数

`setup()`函数是Vue3.0中，专门为组件提供的新属性。它为基于`Composition API`的新特性提供了统一的入口。

#### 1. 执行时机

`setup()`函数会在`created()`生命周期之前执行。

![img](https:////upload-images.jianshu.io/upload_images/19198993-8b00f598477dc683.png?imageMogr2/auto-orient/strip|imageView2/2/w/213/format/webp)

setup执行时机.png

#### 2. 接收props数据

`props`是`setup()`函数的一个形参，组件接收的`props`数据可以在`setup()`函数内访问到。

```js
setup(props) {
    console.log(props.p1)
}
```

#### 3. context上下文对象

`context` 是 `setup()` 的第二个形参，它是一个上下文对象，可以通过 `context` 来访问Vue的实例 `this` 。

```js
setup(props,context) {
    console.log(this)
    console.log(context)
}
```

## 与 2.x 版本相对应的生命周期钩子

| Vue2.x 的生命周期 | Vue3.x 的生命周期 |
| ----------------- | ----------------- |
| ~~beforeCreate~~  | 使用 setup()      |
| ~~created~~       | 使用 setup()      |
| beforeMount       | onBeforeMount     |
| mounted           | onMounted         |
| beforeUpdate      | onBeforeUpdate    |
| updated           | onUpdated         |
| beforeDestroy     | onBeforeUnmount   |
| destroyed         | onUnmounted       |
| errorCaptured     | onErrorCaptured   |

## 新增的钩子函数

除了与 Vue2.x 等效的生命周期之外，`composition-api` 还新增了以下生命周期钩子用作调试：

- onRenderTracked

- `onRenderTracked`直译过来就是`状态跟踪`，它会跟踪页面上所有响应式变量和方法的状态，也就是我们用`return`返回去的值，它都会跟踪。只要页面有`update`的情况，它就会跟踪，然后生成一个`event`对象，我们通过`event`对象来查找程序的问题所在。

  使用`onRenderTracked`同样要使用`import`进行引入。

- onRenderTriggered

- `onRenderTriggered`直译过来是`状态触发`，它不会跟踪每一个值，而是给你变化值的信息，并且新值和旧值都会给你明确的展示出来。

  如果把`onRenderTracked`比喻成散弹枪，每个值都进行跟踪，那`onRenderTriggered`就是狙击枪，只精确跟踪发生变化的值，进行针对性调试。

  使用它同样要先用`import`进行引入

两个钩子函数都接收一个 `DebuggerEvent` :

```js
export default {
  onRenderTriggered(e) {
    debugger
    // 检查哪个依赖性导致组件重新渲染
  },
}
```

# 一三二、Vue3.0虚拟DOM底层原理

https://www.jianshu.com/p/d6125639f000

如果我们绑定的属性是动态元素，那就会加上patch flag 的标识    在vdom更新的之后只会关注它有变化的地方

# 一三三、vue路由 hash 模式和 history 模式实现原理分别是什么，他们的区别是什么？

#### hash 模式：

\#后面 hash 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面

通过监听 hashchange 事件可以知道 hash 发生了哪些变化，然后根据 hash 变化来实现更新页面部分内容的操作。

#### history 模式：

history 模式的实现，主要是 HTML5 标准发布的两个 API，pushState 和 replaceState，这两个 API 可以在改变 url，但是不会发送请求。这样就可以监听 url 变化来实现更新页面部分内容的操作

#### 区别

url 展示上，hash 模式有“#”，history 模式没有

刷新页面时，hash 模式可以正常加载到 hash 值对应的页面，而 history 没有处理的话，会返回 404，一般需要后端将所有页面都配置重定向到首页路由

兼容性，hash 可以支持低版本浏览器和 IE。

# 一三四、new的时候发生了什么？

在内存中创建一个新对象 

将构造函数的作用域赋值给新对象（this指向这个新对象） 

执行构造函数中的代码（为这个新对象添加属性） 

返回新对象 

# 一三五、**-事件循环中的宏任务和微任务**

宏任务 : 事件, 定时器, ajax请求

微任务 : Promise, async/await

# 一三六、**onclick和addEventListener的区别**

onclick同一元素绑多个事件时会覆盖，addEventListener可绑多个不冲突

# 一三七、**什么是纯函数?**

简单概括: **一个函数的** 

返回 **结果只依赖于它的参数, 并且在执行过程里面没有** 副作用 

副作用 **: 一个** 函数 **在执行过程中对外部产生了** 

可观察的变化 **, 那么这个函数就是右** 

副作用 

```JS
/纯函数
function priceAfterTax(productPrice) { return (productPrice * 0.20) + productPrice;}
```

```js
/非纯函数
var tax = 20;
function calculateTax(productPrice) { return (productPrice * (tax/100)) + productPrice;
}
其中函数的计算结果取决于外部 tax 变量，而纯函数不能依赖外部变量。它没有满足定义中的第一个要求，因此这个函数是不纯的。
```

# 一三八、H5C3新特性

```JS
/H5
1.新增了语义化标签,比如 header头部标签,nav导航标签,footer底部标签,section盒子容器等等 
2.新增了视频和音频标签 video 和 audio 
3.新增了本地存储 localstorage(永久性的存储,页面关闭了都还在) sessionstorage(临时性存储,浏览器关闭就没了) 
4.新增了canvas画布 
5.新增了表单属性, 比如time, date等
```

```JS
/C3
颜色: rgba()
过渡: transition 
动画: @keyframes,animation 
2D,3D转换效果:transform 
盒子模型: content-box(标准) border-box(css3盒子模型) 
渐变: liner-gradient 
媒体查询: @media only screen and (width: 320px) 
盒子阴影: box-shabow 
圆角边框: border-radius 
弹性盒子: flex布局
```

# 一三九、**-px、em、rem、vh、vw的区别是什么？**

```JS
px代表物理屏幕上能显示出的最小的一个点, 
em 是相对于父级的字体大小, 
rem是相对于HTML根元素的字体大小, 
vh 和vw相对于视口的高度和宽度,1vh 等于1/100的视口高度，1vw 等于1/100的视口宽度
```

# 一四零、js严格模式

## 严格模式的限制

1、不允许使用未声明的变量
 对象也是一个变量。

```javascript
"use strict"
x = {s1:100, s2:99}; //Uncaught ReferenceError: x is not defined
```

2、不允许对变量或函数使用delete操作符

```javascript
"use strict"
var x = 1;
delete x; //Uncaught SyntaxError: Delete of an unqualified identifier in strict mode.
```

3、不允许变量重名

```javascript
"use strict"
function fs(r1,r1) {
} //Uncaught SyntaxError: Duplicate parameter name not allowed in this context
```

4、不允许使用八进制

```javascript
"use strict"
var x = 012; //Uncaught SyntaxError: Octal literals are not allowed in strict mode.
```

5、抛弃with语句

```javascript
"use strict"
var str = "hello";
with(str) {
  console.log(toUpperCase());
}
//Uncaught SyntaxError: Strict mode code may not include a with statement
```

6、不可对只读对象赋值，不可对不可配置对象使用delete操作符

```javascript
"use strict"
console.log(Object.prototype);
delete Object.prototype; //Uncaught TypeError
console.log(Object.prototype); 
```

7、禁止this关键字指向全局对象

```javascript
"use strict"
function fs() {
  console.log(this);
}
fs();
//undefined
```

8、不可在if内部声明函数

```javascript
"use strict"
var a=0;
if(a<=2) {
  function add() {
    a++;
    return a;
  }
}
add(); //Uncaught ReferenceError: add is not defined
console.log(add()); //非严格模式下返回2
```

# 一四一、**哪些css属性可以继承**

```JS
font-size
line-height
color
text-align
```

# 一四二、**vue与React的区别** 

```JS
相同点: 
1.不管是react的jsx语法,还是vue的.vue文件格式,都需要编译后使用 
2.核心思想相同: 一切都是组件 
不同点: 
1.react采用jsx语法, vue则使用template模板 
2.vue是双向数据绑定, react是单向数据流
```

# 一四三、**route和router的区别**

```JS
router 为Vue-router的实例，是一个 全局的路由对象 ，包含了路由的 跳转的方法、钩子函数 等等
route是一个局部的对象, 当前活跃的， 包含了 path 、 params 、 query 、 matched 、 name 等路由信息参数
```

# 一四四、 iframe是什么？有什么缺点？

```JS
定义：iframe元素会创建包含另一个文档的内联框架
提示：可以将提示文字放在<iframe></iframe>之间，来提示某些不支持iframe的浏览器
缺点：

会阻塞主页面的onload事件
搜索引擎无法解读这种页面，不利于SEO
iframe和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能
```

# 一四五、**一、O2O与B2C的区别**

```JS
一BTC（BusinessToCustomer）

又称B2C，电子商务按交易对象分类中的一种，即表示商业机构对消费者的电子商务。这种形式的电子商务一般以网络零售业为主，主要借助于Internet开展在线销售活动。

B2C模式是我国最早产生的电子商务模式，以8848网上商城正式运营为标志。B2C即企业通过互联网为消费者提供一个新型的购物环境——网上商店，消费者通过网络在网上购物、在网上支付。

由于这种模式节省了客户和企业的时间和空间，大大提高了交易效率，特别对于工作忙碌的上班族，这种模式可以为其节省宝贵的时间。

二 BTB（BusinessToBusiness）

又称B2B，是指一个互联网市场领域的一种，是企业对企业之间的营销关系。它将企业内部网，通过B2B网站与客户紧密结合起来，通过网络的快速反应，为客户提供更好的服务，从而促进企业的业务发展。近年来B2B发展势头迅猛，趋于成熟。

三 OTO（OnlineToOffline）

又称O2O，即“线上到线下”，OTO商业模式的核心很简单，就是把线上的消费者带到现实的商店中去，在线支付购买线下的商品和服务，再到线下去享受服务。
不同点
1，O2O更侧重服务性消费（包括餐饮、电影、美容、SPA、旅游、健身、租车、租房……）；B2C更侧重购物（实物商品，如电器、服饰等等）；
2，O2O的消费者到现场获得服务，涉及客流；；B2C的消费者待在办公室或家里，等货上门，涉及物流;
3，O2O中库存是服务，B2C中库存是商品；
相同点
1，消费者与服务者第一交互面在网上（特别包括手机）；
2，主流程是闭合的，且都是网上，如网上支付，客服等等；
3，需求预测管理在后台，供需链管理是O2O和B2C成功的核心；
```

# 一四六、开发模式

```JS
5，迭代模型（Stagewise-Model）（迭代增量式开发/迭代进化式开发）

在迭代式开发方法中，整个开发工作被组织为一系列的短小的、固定长度（如3周）的小项目，被称为一系列的迭代。每一次迭代都包括了需求分析、设计、实现与测试。采用这种方法，开发工作可以在需求被完整地确定之前启动，并在一次迭代中完成系统的一部分功能或业务逻辑的开发工作。再通过客户的反馈来细化需求，并开始新一轮的迭代。

迭代和版本的区别，可理解如下：迭代一般指某版本的生产过程，包括从需求分析到测试完成；版本一般指某阶段软件开发的结果，一个可交付使用的产品。

优点：

（1）降低了在一个增量上的开支风险。如果开发人员重复某个迭代，那么损失只是这一个开发有误的迭代的花费。

（2）降低了产品无法按照既定进度进入市场的风险。通过在开发早期就确定风险，可以尽早来解决而不至于在开发后期匆匆忙忙。

（3）加快了整个开发工作的进度。因为开发人员清楚问题的焦点所在，他们的工作会更有效率。

（4）由于用户的需求并不能在一开始就作出完全的界定，它们通常是在后续阶段中不断细化的。因此，迭代过程这种模式使适应需求的变化会更容易些。因此复用性更高

7，敏捷开发模型（Agile-Development-Model）

敏捷开发是一种以人为核心、迭代、循序渐进的开发方法。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。

敏捷开发小组主要的工作方式：

（1）作为一个整体工作；

（2）按短迭代周期工作；

（3）每次迭代交付一些成果，关注业务优先级，检查与调整。

敏捷开发的4个核心思想：

（1）强调面对面的沟通，人和人的相互交流胜于任何流程和工具

（2）把精力集中在可执行的程序上，可以运行的产品胜于编制综合性文档，强调了原型、模型、demo等的重要性

（3）团队合作和团队激励，合作胜于谈判，敏捷开发能将需求、开发、测试等全部团队成员融合成一个整体，大家都是一条线上的蚂蚱

（4）超强的适应能力，适应变化胜于按部就班，敏捷开发的特点就是快速

敏捷软件开发要注意项目规模，规模增长，团队交流成本就上去了，因此敏捷软件开发暂时适合不是特别大的团队开发，比较适合一个组的团队使用。
```

# 一四八、new Set 对象作用

- ## **数组去重**

```js
var arr = [1,2,3,3,1,4];
[...new Set(arr)]; // [1, 2, 3, 4]
Array.from(new Set(arr)); // [1, 2, 3, 4]
[...new Set('ababbc')].join(''); // "abc" 字符串去重
new Set('ice doughnut'); //Set(11) {"i", "c", "e", " ", "d", …}
```

- ## **并集**

```js
var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var union = new Set([...a, ...b]); // {1, 2, 3, 4}
```

- ## **交集**

```js
var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var intersect = new Set([...a].filter(x => b.has(x))); // {2, 3}
```

- ## **差集**

```js
var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var difference = new Set([...a].filter(x => !b.has(x))); // {1}
```

# 一四九、nextTick作用，原理

```JS
Vue中DOM的更新是异步的。
虽然Vue一直强调的是数据驱动视图，但是，有时候不可避免要操作DOM的。
在数据变化之后等待 Vue 完成更新 DOM这是一个异步执行的过程，需要用nextTick来搞定。
事件循环
```

# 一五零、vue和react区别与共同点

```JS
共同点：Virtual DOM 组件化 Props 构建工具 Chrome 开发工具 配套框架
```

```JS
区别：模板 vs JSX 状态管理 vs 对象属性 React Native vs. ?
```

# 一五一、sass和less区别

```JS
1.编译环境不一样
Sass是在服务端处理的，以前是Ruby，现在是Dart-Sass或Node-Sass，而Less是需要引入less.js来处理Less代码输出CSS到浏览器，也可以在开发服务器将Less语法编译成css文件，输出CSS文件到生产包目录，有npm less, Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。
2.变量符不一样，Less是@，而Scss是$。
3.Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持。
4.安装体验不同
用npm 或者yarn 安装less非常容易，而安装sass, 在国内没有翻墙的话，要么费了九牛二虎之力才能安装成功，要么就一直报安装失败。安装体验磕磕绊绊，很差劲。
```

# 一五二、Javascript垃圾回收方法

### 标记清除（mark and sweep）

这是`JavaScript`最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。

垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了

### 引用计数(reference counting)

在低版本`IE`中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。

在IE中虽然`JavaScript`对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，也就是说只要涉及BOM及DOM就会出现循环引用问题。

# 一五三、undefind和null的区别

```JS
1、首先看一个判断题：null和undefined 是否相等
    console.log(null==undefined)//true
    console.log(null===undefined)//false
观察可以发现：null和undefined 两者相等，但是当两者做全等比较时，两者又不等。

原因：null： Null类型，代表“空值”，代表一个空对象指针，使用typeof运算得到 “object”，所以你可以认为它是一个特殊的对象值。

          undefined： Undefined类型，当一个声明了一个变量未初始化时，得到的就是undefined。

实际上，undefined值是派生自null值的，ECMAScript标准规定对二者进行相等性测试要返回true，

2、那到底什么时候是null,什么时候是undefined呢？

   null表示"没有对象"，即该处不应该有值。典型用法是：

（1） 作为函数的参数，表示该函数的参数不是对象。

（2） 作为对象原型链的终点。

undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。典型用法是：

（1）变量被声明了，但没有赋值时，就等于undefined。

（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。

（3）对象没有赋值的属性，该属性的值为undefined。

（4）函数没有返回值时，默认返回undefined。
```



# 一五四、小程序上线流程

```JS
1、上传代码
2、提交审核
3、填写APP检索信息方便搜索
4、审核通过后发布版本
```

# 一五五、小程序上线需要注意什么？

```JS
//1.1 小程序名称、简介、logo、服务范围、服务标签、帐号基本信息文字均不得：
​（1）侵犯他人权益（著作权、商标权、肖像权、名誉权等）。包括但不限于，使用或包含不属于该小程序主体的品牌或商标、标识等内容或与之相似的内容、信息、特殊角标。示例：检查名称、简介中是否含有该小程序不属于该帐号的权益。
​（2）含有商业化用语的、热门小程序名称、“国家级”、“最高级”等新广告法明令禁止或其他无关的词语。
​（3）含有政治、色情、敏感、暴力血腥、恐怖、其他国家法律法规禁止的词汇及违法内容。
//1.2.1 小程序名称、简介：
​（1）小程序的简介需明确介绍小程序的功能点，不能使用模糊的词义表达，比如：该小程序旨在提高用户的生活品味、该小程序旨在提高用户的购物体验。示例：能在简介中提炼该小程序的几个功能点。
​（2）名称、简介的信息表达的意思必须有关联，具有一致性，并应与实际提供的功能一致，不含有与功能无关的搜索热词。示例：简介中能找到小程序名称或者分拆出来的词。
​（3）小程序名称不能以电话、邮件、日历、小游戏等广义归纳类、斗地主、麻将等通用游戏名称类、或者其他普遍且不具有识别性词语来命名。示例：名称不是单词汇，必须是两个词以上的组合，当无法判断时，审核人员可主观判断。
//1.2.2 小程序头像logo：
​（1）小程序头像logo清晰度不够时，不予通过。示例：无法看清、分辨、识别图片中包含的各个元素，如：文字、物体、形状等。
​（2）小程序头像logo应与名称、简介保持一致。
（3）小程序头像logo不得包含腾讯、微信等官方品牌标识。
//2.1 小程序的类目要和自身所提供的服务一致。
​2.1.1 小程序服务类目所对应的页面中的核心内容必须与该类目一致。
​2.1.2 必须保证用户在该页面能使用该服务类目，不得隐藏，不得进行多次跳转。
2.1.3 你需根据实际提供服务范围慎重选择服务类目，一旦你选择了游戏类目，该类目将不可修改变更为其他小程序类目。
//3.3 可用性和完整性
​3.3.1 提交的小程序须是一个完成品，要求可以打开，可以运行，且不可以是一个测试版。示例：不可运行、存在崩溃、闪退、按钮没有响应、文字表述不完整等。
​3.3.2 本身会崩溃，或小程序程序会造成微信客户端崩溃的，将会被拒绝。
​3.3.3 存在严重Bug的小程序（如无法添加和打开、无法返回和退出、卡顿严重等），将会被拒绝。
​3.3.4 若小程序中存在帐号体系，需提供测试号，包含帐号和密码（可以体验所有功能）。
```

# 一五六、自执行函数this指向window

# 一五七、xml和html

# 一五八、会改变数组的方法与不会改变的

## 会改变

```JS
PUSH
POP
shift
unshift
splice
sort
reverse
forEach
```

## 不会改变

```JS
filter
concat
slice
map
```

# 一五八、后加加

```JS
var a=3
aleat(a++) //3
a++
aleat(a) //4
```

# 一五九、vue渲染为什么是异步

```JS
因为vue是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能考虑，vue在本来数据更新后，再去异步更新视图。
```

# 一六零、首屏加载优化

```JS
通过webpack-bundle-analyer 进行检测
按需引入
路由懒加载
```

# 一六一、$set什么用？

```JS
直接对对象添加新的属性不会触发视图更新，所以使用$set(对象名，键名，值)
```

# 一六二、发布订阅模式

发布者  调度中心 订阅者

# 一六三、观察者模式

观察者 被观察者 当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。

# 一六四、箭头函数除了没有this指向还有什么特点？

```JS
1.this方面：

普通函数内部的this，默认指向window，严格模式下指向undefined；

箭头函数内部的this，与上一级作用域中的this指向同一个地方。

2.arguments方面：

普通函数，可以通过arguments来实现重载；

箭头函数中，没有arguments，代替它功能是剩余参数rest（...）。

3.原型对象方面：

普通函数，是有自己的原型对象的；

箭头函数，没有原型对象。

4.new方面：

普通函数，可以作为构造函数，通过new实例化出子函数；

箭头函数，不能作为构造函数，使用new会报错。

5.简易程度：

箭头函数比普通函数的使用简短更多；同时箭头函数通常是匿名函数。
```

# 一六五、content-type常用类型

```JS
一、application/x-www-form-urlencoded
最常见的POST提交数据的方式,原生Form表单,如果不设置enctype属性,默认为application/x-www-form-urlencoded方式提交数据。
首先,Content-Type都指定为application/x-www-form-urlencoded;其次,提交的表单数据会转换为键值对并按照key1=val&key2=val2的方式进行编码,key和val都进行了URL转码。大部分服务端语言都对这种方式有很好的支持。
另外,如利用AJAX提交数据时,也可使用这种方式。例如jQuery,Content-Type默认值都是"application/x-www-form-urlencoded;charset=utf-8"。

二、multipart/form-data
另一个常见的POST数据提交的方式,Form表单的enctype设置为multipart/form-data,它会将表单的数据处理为一条消息,以标签为单元,用分隔符(这就是boundary的作用)分开,类似我们上面Content-Type中的例子。
由于这种方式将数据有很多部分,它既可以上传键值对,也可以上传文件,甚至多个文件。当上传的字段是文件时,会有Content-Type来说明文件类型;Content-disposition,用来说明字段的一些信息。每部分都是以-boundary开始,紧接着是内容描述信息,然后是回车,最后是字段具体内容(字段、文本或二进制等)。如果传输的是文件,还要包含文件名和文件类型信息。消息主体最后以-boundary-标示结束。

三、application/json
Content-Type: application/json作为响应头比较常见。实际上,现在越来越多的人把它作为请求头,用来告诉服务端消息主体是序列化后的JSON字符串,其中一个好处就是JSON格式支持比键值对复杂得多的结构化数据。由于JSON规范的流行,除了低版本IE之外的各大浏览器都原生支持JSON.stringify,服务端语言也都有处理JSON的函数,使用起来没有困难。
Goodle的AngularJS种的Ajax功能,默认就是提交JSON字符串。

四、text/xml
答: XML的作用不言而喻,用于传输和存储数据,它非常适合万维网传输,提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据,在JSON出现之前是业界一大标准(当然现在也是),相比JSON的优缺点大家有兴趣可以上网search。因此,在POST提交数据时,xml类型也是不可缺少的一种,虽然一般场景上使用JSON可能更轻巧、灵活。
```



vue和react的区别  

vue的filter用在哪  怎么用

如何管理内存的，垃圾回收机制的标记清除引用计数是什么？

null和undefined的区别

commit常用类型

v-if="flag == item.ID"


1、vue的生命周期？
2、vue：v-model的原理？
3、v-if和v-show的区别？
4、vuex的理解？
5、spa的优缺点？
6、vue的单向数据流？
7、vue兄弟组件之间怎么传值？
8、keep-live的了解？
9、项目中vue路由用的哪一种？
10、hash模式的原理？
11、hash模式和history模式的区别
12、history有什么缺点？
13、vue3和vue2的区别？
14、虚拟dom以及优缺点？
15、vue开发前端优化？
16、浏览器url地址输入网址发什么了什么？
17、ajax的请求过程？
18、闭包的理解以及缺点?
19、js的==和===的区别?
20、typeof和instanceof的区别?
21、new一个对象都发生了哪些事情?
22、var和let有什么区别呢?
23、h5新增了什么特性？
24、localStorage和sessionStorage的区别？
25、websocket用过吗？
26、让一个图片垂直居中？
27、css的优先级？
28、你认为自己有什么优势?
29、哪些是自己线下学的
30、地图组件用过吗？
31、3D建模
32、echarts柱状图的渐变
33、大概从事哪些方面工作
34、flex布局的align-items和align-content的区别
35、页面的组题换肤
36、hope图？
37、settimout倒计时为什么会有误差？

1. history使用哪个方法监听变化的
2.为什么请求数据要写在mouted不写在created里
3.$set用过吗？
4.虚拟dom是在哪个钩子函数执行时创建的
5.vue响应式原理与订阅发布模式是怎么结合的
6.getter和setter那个是收集依赖的，哪个是更新依赖的
7.原声js减少dom操作的方法
8. cookie和storage的区别
9.如何实现cookie跨域
10.tcp和udp区别
11. content-type都有什么类型
12. options请求
13.非对称加密
14.首屏加载处理
15.箭头函数除了没有this指向还有什么特点？
16.v-if和v-for哪个先执行
17.拦截器里边一般写哪些东西







